# 简单的操作系统实现

## 环境

Ubuntu 18.04/16.04

QEMU 模拟器

as 汇编器

## 编程规范

1. 开始编程前请确保已经与远程库同步, 编写, 测试之后及时同步到远程库
2. 除了 `Makefile` 外, 全部使用空格控制缩进 (即软tab)
3. 汇编代码使用 8 个空格缩进, C代码使用 4 个空格缩进

## 文件列表

- **boot**:
  - `bootsect.S`: 启动区, 编译后被放在软盘的第一个扇区 (512 字节), 加载初始化程序并跳转
  - `setup.S`: 初始化程序, 编译后被放在软盘的第二到第五扇区, 完成一些初始化工作然后跳转到操作系统
- **system**:
  - `sys_head.S`: 调用 `main()`, 确保 C 代码从 `main()` 开始执行, 并为 C 语言提供一些函数
  - **headers**:
    - `macro_def.h`: 宏定义, 涉及到一些参数
    - `struct_def.h`: 结构体的定义
    - `func_def.h`: 各种函数的声明
  - **C**:
    - `os_main.c`: `main()` 函数的定义, 操作系统的起点
    - `builtin_commands.c`: 终端的命令的实现
    - `byte_buffer.c`: 字节缓冲区(FIFO)相关功能的实现
    - `console_io.c`: 包含控制台输出的相关函数的实现
    - `hard_disk.c`: 硬盘IO的实现
    - `hardware_init.c`: 硬件初始化函数的实现
    - `men_manage.c`: 内存管理相关函数的实现
    - `terminal.c`: 终端的实现, 负责监控键盘缓冲区, 解析命令
    - `text_video.c`: VGA 0x03 号字符模式下画面控制相关函数的实现
    - `time.c`: 定时器相关功能的实现
- 其他:
  - `ld_script.ld` 链接脚本, 用于去掉 elf 文件头

## `bootsect.S` 启动区

1. 启动时, 被加载到 `[0x07c00, 0x07e00)`
2. 把 `setup.S` 加载到 `[0x80000, 0x80800)`
3. 跳转到 `setup.S` 进行操作系统的初始化

## `setup.S` 操作系统初始化程序

1. 把 C0-H0-S6 ~ C19-H1-S18 这 715 个扇区的内容加载到 `[0x10000, 0x69600)` 的位置. 这也是目前限定的操作系统的大小 (357kb应该足够使用)
2. 打开 A20 地址线
3. 切换图形模式 `VGA 0x03 80x25x16 text`, 显存从 `0xb8000` 开始, 每 2 个 byte 表示一个位置的字符, 前者是 ASCII 值, 后者是颜色
4. 保存硬盘参数
5. 把操作系统移动到 `[0x00000, 0x59600)`
6. 设置 GDT, GDTR 的值为 `0x59700|0x0f00`
7. 进入保护模式
8. 跳转到 `0x0000` 继续执行

## `system`

生成 `system` 就是操作系统, 会被加载到 `0x0000`.

目前 `system` 由 `sys_head.S` 和 C 语言代码拼接而成.

`sys_head.S` 会先初始化页表, 然后跳转到 `main()` 函数.

`main()` 函数中也是先进行一些初始化工作, 然后进入终端, 至此, 用户可以操作, 输入命令.

## 内存分布

(进入 system 之后, 这个图是上闭下开的区间)

```

+----0x00000000----+
|                  |
|                  |
|                  |
|      system      |
|                  |
|                  |
|                  |
+----0x00059600----+
|      empty       |
+----0x00059700----+
|                  |
|       GDT        |
|   at most 3072   |
|   Descriptors    |
|                  |
+----0x0005f700----+
|    hdd params    |
+----0x00060000----+
|                  |
|       IDT        |
|   at most 256    |
|    Interrupts    |
|                  |
+----0x00060200----+
|                  |
|      system      |
|      stack       |
|                  |
+----0x000a0000----+
|                  |
|      empty       |
|                  |
+----0x000b8000----+
|                  |
|  VGA text VRAM   |
|                  |
+----0x000b8fa0----+
|                  |
|                  |

```

## 文件系统

通过 ATA 读写硬盘, 实现了一个简单的文件系统. 可以使用 `qemu-img` 指令制作一个固定大小的硬盘, 然后作为 0 号硬盘挂载.

### 目录结构

类 Unix, 通过路径对文件索引. 所有路径组成树结构, 根节点为根目录 `/`. 每深入一层, 即进入一个子目录. 每一个节点是一个文件或者文件夹, 如果是文件, 那么这个节点要记录这个文件的第一个储存块的位置; 如果是文件夹, 那么这个节点可以有子节点.

树结构是逻辑上的, 实际上以左儿子右兄弟的二叉树储存这棵树. 节点如下:

```C++
struct file_directory
{
    char name[MAX_NAME_BYTE];      // 目录名/文件名

    struct file_directory *left;   // 左儿子, 当前目录中的内容
    struct file_directory *right;  // 右兄弟, 相当于一个链表, 处于同一目录下的内容
    struct file_directory *father; // 上级目录

    struct blk_ptr blk, lblk, rblk; // 当前/左/右子节点在硬盘中的位置

    int start_block;      // -1 表示是目录, 否则是文件, 并且记录该文件在硬盘中的起始块号
};
```

通过这样的树结构, 可以实现通过路径索引一个文件. 这个结构是在内存中的储存形式, 这个结构还应该储存在硬盘中.

### 目录结构在硬盘中的储存

初始应该从硬盘读入该树结构. 并且在涉及文件操作的时候同时在内存和硬盘中更改这个树结构. 在硬盘中 `left, right, father` 这三个指针没有意义, 因此不储存. 使用 `blk, lblk, rblk` 记录当前节点, 左子节点, 右子节点在硬盘中的位置.

```C
struct blk_ptr
{
    uint block, index;   
};
```

`block` 表示块号, `index` 表示当前块的字节位置. `index >= 1024` 表示不存在.

设定名称最大为 24 位(即 23 个字符), 那么一个 `file_directory` 占 64 byte. 一个块可以储存 16 个节点.

### 硬盘块的使用 (文件的储存)

一个文件的索引仅仅有一个 `start_block`. 表示这个文件的起始块号. 

一个 1024B 的硬盘块:

1. 前 1000B 用来储存文件内容
2. 最后 4B (一个 uint) 表示文件在该块的大小 (> 1000表示本块占满, 还有下一块)
3. 倒数第2个 4B 表示这个文件的下一块的块号

### 硬盘块的管理

对硬盘块的管理与内存管理相似. 

对于文件本身, 只需要按块分配. 直接使用二进制位映射每一块的使用情况即可.

对于索引树, 每 16 个节点共用一个块, 所以使用二进制位映射每 64 byte 的使用情况.

使用 0 号硬盘块储存索引树的使用情况. 共有 1024 * 8 = 8192 个二进制位, 即最大支持 8192 个索引节点的管理.

使用 1 ~ 5 号硬盘块储存硬盘块的使用情况. 共有 32768 个二进制位, 即最大支持 32768 KB 的硬盘

使用 6 ~ 255 号硬盘块储存索引树. 即实际最大支持 250 * 16 = 4000 个索引节点. 

256号 之后的块用于储存文件.

**规定**: 根目录的索引节点必须位于 6 号硬盘块的第一个位置.

初始化硬盘时会:

1. 将 0 ~ 5 号块读入内存.
2. 根据 0 号块的储存情况将索引树读入内存.
  - 首先检查 0 号块的 64 号二进制位(对应6号块的第一个索引节点的使用情况), 需要是 1, 否则代表硬盘未初始化
  - 如果检查通过, 那么到6号块读入根目录节点
  - 每读入一个节点, 检测它的 blk 是否一致, 如果不一致, 代表硬盘未初始化
  - 每读入一个节点, 根据 lblk 和 rblk 读入子树, 并且检查储存情况是否一致, 如果不一致, 代表硬盘未初始化

如果硬盘未初始化, 那么新建根目录, 初始化前 6 个块. 相当于格式化.

## 备注

1. 目前从软盘启动, 改成从硬盘驱动, 需要修改 bootsect.S 和 setup.S 中的 INT 0x13 调用的参数
2. 打印字符串的一些调用可以风格统一/优化
3. 目前不太清楚 BIOS 中设置的显示模式和进入操作系统之后设置的显示模式有什么关系, 当然, 我们的操作系统不会涉及这一点